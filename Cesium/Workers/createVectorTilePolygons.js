/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.98
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["./AttributeCompression-aa7855e7","./Matrix2-7dfd434a","./Color-75edef0e","./defaultValue-50f7432c","./IndexDatatype-ceed713e","./ComponentDatatype-9b23164a","./OrientedBoundingBox-69290b47","./createTaskProcessorWorker","./RuntimeError-48e1f06d","./Transforms-f305a473","./combine-8462e002","./WebGLConstants-58abc51a","./EllipsoidTangentPlane-03ebf5f4","./AxisAlignedBoundingBox-a2ff9dfd","./IntersectionTests-4a7694f7","./Plane-3d30b188"],(function(e,t,n,a,r,o,i,s,c,f,d,l,u,h,g,p){"use strict";const b=new t.Cartesian3,m=new t.Ellipsoid,y=new t.Rectangle,C={min:void 0,max:void 0,indexBytesPerElement:void 0};function I(e,t,a){const r=t.length,o=2+r*i.OrientedBoundingBox.packedLength+1+function(e){const t=e.length;let a=0;for(let r=0;r<t;++r)a+=n.Color.packedLength+3+e[r].batchIds.length;return a}(a),s=new Float64Array(o);let c=0;s[c++]=e,s[c++]=r;for(let e=0;e<r;++e)i.OrientedBoundingBox.pack(t[e],s,c),c+=i.OrientedBoundingBox.packedLength;const f=a.length;s[c++]=f;for(let e=0;e<f;++e){const t=a[e];n.Color.pack(t.color,s,c),c+=n.Color.packedLength,s[c++]=t.offset,s[c++]=t.count;const r=t.batchIds,o=r.length;s[c++]=o;for(let e=0;e<o;++e)s[c++]=r[e]}return s}const x=32767,w=new t.Cartesian3,A=new t.Cartesian3,E=new t.Cartesian3,N=new t.Cartesian3,T=new t.Cartesian3,B=new t.Cartographic,k=new t.Rectangle;return s((function(s,c){let f;!function(e){const n=new Float64Array(e);let a=0;C.indexBytesPerElement=n[a++],C.min=n[a++],C.max=n[a++],t.Cartesian3.unpack(n,a,b),a+=t.Cartesian3.packedLength,t.Ellipsoid.unpack(n,a,m),a+=t.Ellipsoid.packedLength,t.Rectangle.unpack(n,a,y)}(s.packedBuffer),f=2===C.indexBytesPerElement?new Uint16Array(s.indices):new Uint32Array(s.indices);const d=new Uint16Array(s.positions),l=new Uint32Array(s.counts),u=new Uint32Array(s.indexCounts),h=new Uint32Array(s.batchIds),g=new Uint32Array(s.batchTableColors),p=new Array(l.length),L=b,O=m;let U=y;const P=C.min,F=C.max;let S,D,R,M=s.minimumHeights,_=s.maximumHeights;a.defined(M)&&a.defined(_)&&(M=new Float32Array(M),_=new Float32Array(_));const G=d.length/2,V=d.subarray(0,G),Y=d.subarray(G,2*G);e.AttributeCompression.zigZagDeltaDecode(V,Y);const v=new Float64Array(3*G);for(S=0;S<G;++S){const e=V[S],n=Y[S],a=o.CesiumMath.lerp(U.west,U.east,e/x),r=o.CesiumMath.lerp(U.south,U.north,n/x),i=t.Cartographic.fromRadians(a,r,0,B),s=O.cartographicToCartesian(i,w);t.Cartesian3.pack(s,v,3*S)}const H=l.length,W=new Array(H),z=new Array(H);let Z=0,j=0;for(S=0;S<H;++S)W[S]=Z,z[S]=j,Z+=l[S],j+=u[S];const q=new Float32Array(3*G*2),J=new Uint16Array(2*G),K=new Uint32Array(z.length),Q=new Uint32Array(u.length);let X=[];const $={};for(S=0;S<H;++S)R=g[S],a.defined($[R])?($[R].positionLength+=l[S],$[R].indexLength+=u[S],$[R].batchIds.push(S)):$[R]={positionLength:l[S],indexLength:u[S],offset:0,indexOffset:0,batchIds:[S]};let ee,te=0,ne=0;for(R in $)if($.hasOwnProperty(R)){ee=$[R],ee.offset=te,ee.indexOffset=ne;const e=2*ee.positionLength,t=2*ee.indexLength+6*ee.positionLength;te+=e,ne+=t,ee.indexLength=t}const ae=[];for(R in $)$.hasOwnProperty(R)&&(ee=$[R],ae.push({color:n.Color.fromRgba(parseInt(R)),offset:ee.indexOffset,count:ee.indexLength,batchIds:ee.batchIds}));for(S=0;S<H;++S){R=g[S],ee=$[R];const e=ee.offset;let n=3*e,r=e;const o=W[S],s=l[S],c=h[S];let d=P,b=F;a.defined(M)&&a.defined(_)&&(d=M[S],b=_[S]);let m=Number.POSITIVE_INFINITY,y=Number.NEGATIVE_INFINITY,C=Number.POSITIVE_INFINITY,I=Number.NEGATIVE_INFINITY;for(D=0;D<s;++D){const e=t.Cartesian3.unpack(v,3*o+3*D,w);O.scaleToGeodeticSurface(e,e);const a=O.cartesianToCartographic(e,B),i=a.latitude,s=a.longitude;m=Math.min(i,m),y=Math.max(i,y),C=Math.min(s,C),I=Math.max(s,I);const f=O.geodeticSurfaceNormal(e,A);let l=t.Cartesian3.multiplyByScalar(f,d,E);const u=t.Cartesian3.add(e,l,N);l=t.Cartesian3.multiplyByScalar(f,b,l);const h=t.Cartesian3.add(e,l,T);t.Cartesian3.subtract(h,L,h),t.Cartesian3.subtract(u,L,u),t.Cartesian3.pack(h,q,n),t.Cartesian3.pack(u,q,n+3),J[r]=c,J[r+1]=c,n+=6,r+=2}U=k,U.west=C,U.east=I,U.south=m,U.north=y,p[S]=i.OrientedBoundingBox.fromRectangle(U,P,F,O);let x=ee.indexOffset;const G=z[S],V=u[S];for(K[S]=x,D=0;D<V;D+=3){const t=f[G+D]-o,n=f[G+D+1]-o,a=f[G+D+2]-o;X[x++]=2*t+e,X[x++]=2*n+e,X[x++]=2*a+e,X[x++]=2*a+1+e,X[x++]=2*n+1+e,X[x++]=2*t+1+e}for(D=0;D<s;++D){const t=D,n=(D+1)%s;X[x++]=2*t+1+e,X[x++]=2*n+e,X[x++]=2*t+e,X[x++]=2*t+1+e,X[x++]=2*n+1+e,X[x++]=2*n+e}ee.offset+=2*s,ee.indexOffset=x,Q[S]=x-K[S]}X=r.IndexDatatype.createTypedArray(q.length/3,X);const re=ae.length;for(let e=0;e<re;++e){const t=ae[e].batchIds;let n=0;const a=t.length;for(let e=0;e<a;++e)n+=Q[t[e]];ae[e].count=n}const oe=I(2===X.BYTES_PER_ELEMENT?r.IndexDatatype.UNSIGNED_SHORT:r.IndexDatatype.UNSIGNED_INT,p,ae);return c.push(q.buffer,X.buffer,K.buffer,Q.buffer,J.buffer,oe.buffer),{positions:q.buffer,indices:X.buffer,indexOffsets:K.buffer,indexCounts:Q.buffer,batchIds:J.buffer,packedBuffer:oe.buffer}}))}));
